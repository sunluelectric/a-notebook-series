%\chapterauthor{Author Name}{Author Affiliation}
%\chapterauthor{Second Author}{Second Author Affiliation}
\chapter{File Management} \label{ch:fm}

File management is a big portion of OS. In Linux, each device (such as a printer) is treated and managed as a file, and Linux uses a tree hierarchy to manage devices and files. This chapter introduces the filesystem hierarchy and commonly used file management commands.

\section{Filesystem Hierarchy} \label{ch:fm:sec:hierarchy}

Linux system has the \mync{root directory} which is denoted by a single forward slash ``\verb|/|''. All sub directories or files can be located by its full path, which looks like the following
\begin{lstlisting}
/<directory>/<directory>/.../<directory or file>
\end{lstlisting}
where the first \verb|/| represents the root directory, and sequential \verb|<directory>/| represents a subdirectory under its root.

Upon Linux installation, a \mync{filesystem hierarchy} is created. A user can create new files under this hierarchy framework, but should not change the framework itself. The hierarchy is given in Fig. \ref{ch:fm:fig:hierarchy}. Notice that different Linux distributions may differ slightly on how the architecture looks like. The ``\verb|/|'' in the figure, as introduced, stands for the root directory, and ``\verb|root|'' in the figure is a subdirectory under \verb|/| whose directory name is ``root'' and it is used store root user related documents. They are two different directories.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=250pt]{chapters/part-1/figures/linux_file_hierarchy.png}
	\caption{An example of Linux file system hierarchy.} \label{ch:fm:fig:hierarchy}
\end{figure}

A regular user's home directory is often located at \verb|/home/<user name>|. When logging in as a regular user, his home directory is stored in the HOME environmental variable and can be retrieved by \verb|$HOME|. A shortcut to \verb|$HOME| is given by the tilde \verb|~| for convenience. Hence, for example \verb|ls ~| lists down the files and directories under his home directory.

As can be seen from Fig. \ref{ch:fm:fig:hierarchy}, the hierarchy contains quite a few pre-determined subdirectories, each serving a different purpose. For the ease of illustration, these subdirectories are roughly categorized by functionalities and accessibility shown in Fig. \ref{ch:fm:fig:directorycate}.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=350pt]{chapters/part-1/figures/linux_directory_cate.png}
	\caption{A rough categorization of commonly used directories in Linux file hierarchy standard.} \label{ch:fm:fig:directorycate}
\end{figure}

A brief introduction to the directories are summarized in Table \ref{ch:fm:tab:hierarchyintro}.

\begin{table}[!htb]
  \centering \caption{Introduction to commonly used directories in Linux file hierarchy standard.}\label{ch:fm:tab:hierarchyintro}
  \begin{tabularx}{\textwidth}{lX}
    \hline
    Directory & Description \\ \hline
    \verb|/bin|, \verb|/sbin| & Executables used by the OS, the administrator, and the regular users. \\ 
    \verb|/lib| & Libraries to support \verb|/bin| and \verb|/sbin|. \\ 
    \verb|/usr/bin|, \verb|/usr/sbin| & Executables used by the administrator and the regular users. \\ 
    \verb|/usr/lib| & Libraries to support \verb|/usr/bin| and \verb|/usr/sbin|. \\ 
    \verb|/opt| & Application software installed by OS and administrator for all users. \\ 
    \verb|/var| & Directories of data used by applications. \\ 
    \verb|/usr/local| & Application software installed by administrator for all users. \\ 
    \verb|/usr/share| & Architecture-independent sharable text files for applications. \\ 
    \verb|/usr/src| & Source files or packages managed by software manager. \\ 
    \verb|/dev| & Files representation of devices, such as CPU, RAM, hard disks. \\ 
    \verb|/media| & System mounts of removable media. \\ 
    \verb|/mnt| & Manual mounts of devices. \\ 
    \verb|/etc| & Configuration files for OS, users, and applications. \\ 
    \verb|/boot| & Linux bootable kernel and initial setups. \\ 
    \verb|/proc| & System resources information. \\ 
    \verb|/sys| & Linux kernel information, including a mirror of the kernel data structure. \\ 
    \verb|/tmp|, \verb|usr/tmp| & Temporary files. \\ 
    \verb|/root| & Root user's home directory. \\ 
    \verb|/home/<user name>| & A regular user's home directory, containing executables, configurations and files specifically belong to this user. \\
    \hline
  \end{tabularx}
\end{table}

Linux file hierarchy standard differs from MS-DOS and Windows in several ways. Firstly, Linux stores all files (regardless of their physical location) under the root directory, while Windows uses drive letters such as \verb|C:\|, \verb|D:\| to distinguish different hard drives. Secondly, Linux uses slash (\verb|/|) to separate directory names, e.g. \verb|/home/username| while Windows uses back slash (\verb|\|), e.g. \verb|C:\Users\username|. Lastly, Linux uses ``magic numbers'' to indicate file types, while Windows often uses suffixes to tell file types. 

Magic numbers of a file refer to the first few bytes of a file that are unique to a particular file type, for example, PNG file is hex \verb|89 50 4e 47|. Linux compare the magic numbers of a file with an internal database to decide the file types and features. Distinguishing file types using magic numbers can be more reliable than using suffixes, though a bit less intuitive.

\section{Hard and Soft Links}

The files are stored in the physical disk, and the name (including path) of the file is nothing but a ``link'' to that storage. The user and the OS can reach and manipulate the storage using the file name. 

In addition to the original file name, Linux allows the user to create \mync{hard link} or \mync{soft link} (also known as \mync{symbolic link}) to refer to a file. A demonstrative plot is given in Fig. \ref{fig:hardsoftlink}. More details are introduced in the rest of the section.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=250pt]{chapters/part-1/figures/hardsoftlink.png}
	\caption{Original file name, hard link and soft link.} \label{fig:hardsoftlink}
\end{figure} 

\subsection{Hard Link}

As shown in Fig. \ref{fig:hardsoftlink}, a hard link is an alternative to the file name that directly points to the stored data. Both the original file name and the hard link share the same \mync{inode number}. The inode number is a unique identifier of a file that Linux uses to map a file name to the stored data. From this sense, a hard link is equivalent to the original file name, and the original file name can be taken as the ``default hard link''.

If a file is associated with additional hard links, removing the original file does not erase the data, and the data is still accessible via the remaining hard links. Only when all the hard links are removed, should the OS mark the storage as ``free'' and the data might be erased in the future when new data comes in. This is because the OS traces the link account of an inode number (the number of hard links to an inode number, the original file name included), and will consider the data removable only if it drops to 0.

Hard links can be used as a back up of the original file just in case its original file name is deleted by accident. Notice that a hard link does not create a duplication of the data referred by the original file name. 

Use
\begin{lstlisting}
$ ln <file> <hard link>
\end{lstlisting}
to create a hard link for a file.

\subsection{Soft Link}

As shown in Fig. \ref{fig:hardsoftlink}, a soft link or a symbolic link is a second-layer point of the data. The soft link does not point to the data in the physical storage directly, but points to another link and forms a chain. If any links in the chain is broken, the soft link becomes a dangling link and loses the reference to the data. Notice that there is a limit to the length of the chain which effectively avoids looped chain. A larger overhead of processing time is expected as the chain becomes longer.

Soft links are useful to create shortcuts or cross-file system links.

Use
\begin{lstlisting}
$ ln -s <file> <soft link>
\end{lstlisting}
to create a soft link for a file.

\section{Commonly Used File Exploring Commands} \label{ch:fm:sec:filemanagement}

Some of the most widely used file exploring and managing commands are summarized in Table \ref{ch:fm:tab:commonfilecommands}. 

In Table \ref{ch:fm:tab:commonfilecommands}, \verb|chmod| and \verb|chown| are administration related commands that change the accessibility of a directory or a file and they will be introduced in details in Sections \ref{sec:chown} and \ref{sec:chmod} as part of Linux permission system. The rest commands are categorized into two types, query (read only) and manipulation (read and write), and are introduced in the remaining of the section.

\begin{table}[!htb]
  \centering \caption{Commonly used commands to navigate in the Linux file system.}\label{ch:fm:tab:commonfilecommands}
  \begin{tabularx}{\textwidth}{lX}
    \hline
    Command & Description \\ \hline
    \verb|pwd| & Print working directory. \\ 
    \verb|ls| & List the subdirectories and files (and their detail information) in a given directory. \\ 
    \verb|tree| & List the subdirectories and files in a tree hierarchy. \\  
    \verb|touch| & Create an empty file. \\ 
    \verb|mkdir| & Create an empty subdirectory. \\ 
    \verb|mv| & Move (cut-and-paste) a directory or a file; change name of a directory or a file. \\ 
    \verb|cp| & Copy-and-paste a directory or a file. \\ 
    \verb|rm|, \verb|rmdir| & Remove a directory or a file (not to Trash, but just gone). \\ 
    \verb|chmod| & Change permission. \\ 
    \verb|chown| & Change ownership. \\
    \hline
  \end{tabularx}
\end{table}

\subsection{Information Retrieval}

As given in Table \ref{ch:sb:tab:shellenvironmentvars}, \verb|$PWD| is the environmental variables to store the current working directory of the shell. Therefore, to print the current working directory in the console, use command 
\begin{lstlisting}
$ echo $PWD
\end{lstlisting}
Alternatively, use \verb|pwd| as follows which has the same effect.
\begin{lstlisting}
$ pwd
\end{lstlisting}

As one of the most frequently used commands, \verb|ls| lists down information about the files and subdirectories in the selected directory, and by default sort the entries alphabetically. The syntax is given below.
\begin{lstlisting}
$ ls [<option>] [<path>]
\end{lstlisting}

An example is given in Fig. \ref{ch:fm:fig:lscommandexample}. As shown in the example, command \verb|ls| alone shows only the name of files and subdirectories excluding hidden items and details of each item. With the additional arguments in the option field, the returns can be customized with more details displayed. For example in Fig. \ref{ch:fm:fig:lscommandexample}, the \verb|-l| argument displays the information in long listing form, which includes the owner and access control list information. More details about files and directories access control list are given in later part of this section.

\begin{figure}[!htb]
	\centering
	\includegraphics[width=0.8\textwidth]{chapters/part-1/figures/ls_command_example.png}
	\caption{List down information of files and subdirectories in the current working directory.} \label{ch:fm:fig:lscommandexample}
\end{figure}

More information can be found in the \verb|ls| command manual which is accessible via \verb|ls --help|. Some commonly used \verb|ls| arguments are summarized in Table \ref{ch:fm:tab:lscommandargument}. It is also possible to combine the options. For example, \verb|ls -al| aggregates the effects of using \verb|ls -a| and \verb|ls -l|.

\begin{table}[!htb]
  \centering \caption{Commonly used arguments and their effects for \textit{ls} command.}\label{ch:fm:tab:lscommandargument}
  \begin{tabularx}{\textwidth}{lX}
    \hline
    Directory & Description \\ \hline
    \verb|-a|, \verb|--all| & Include hidden files and subdirectories in the display, including current directory ``\verb|.|'' and parent directory ``\verb|..|'' in the list. \\ 
    \verb|-A|, \verb|--almost-all| & Include hidden files and subdirectories in the display, excluding ``\verb|.|'' and ``\verb|..|''. \\ 
    \verb|-C|, \verb|--color[=WHEN]| & Colorize the output. \\ 
    \verb|-l| & Use a long listing format. \\ 
    \verb|-s|, \verb|--size| & Print the allocated size of each file, in blocks. \\ 
    \verb|-S| & Sort the displayed content. \\ 
    \verb|-t| & Sort by modification time. \\
    \hline
  \end{tabularx}
\end{table}

Notice that some Linux distributions may come with aliases about \verb|ls|, which usually helps to displays the information in a clearer manner. For example, when \verb|ls='ls --color-auto'| is used, the displayed content will be colored based on the type of the files and subdirectories.

Use \verb|tree| to check the subdirectories structures of a directory as follows.
\begin{lstlisting}
$ tree <directory>
\end{lstlisting}

Use \verb|cat| to display the content of a text file in the console. When the text files are long, the relevant information can be difficult to find. It is recommended to use \verb|grep| or \verb|egrep| to query or filter the text files as follows.
\begin{lstlisting}
$ cat <file / wildcards> | grep "<keyword>"
\end{lstlisting}
or
\begin{lstlisting}
$ grep "<keyword>" <file / wildcards>
\end{lstlisting}

\subsection{Manipulation}

The \verb|touch| command is used to update the timestamps of a file. If the file does not exist, \verb|touch| creates an empty file. To do so, simply run \verb|touch| followed by the file path:
\begin{lstlisting}
$ touch [<option>] <path>
\end{lstlisting}

For example:
\begin{lstlisting}
$ touch ~/test
\end{lstlisting}
creates an empty file named \texttt{test} in the user’s home directory. If only a filename is given, the file is created in the current working directory. Note that if a filename begins with ``\verb|.|'', it is treated as a hidden file.

Command \verb|touch| can also create multiple files in a single command. For example:
\begin{lstlisting}
$ touch test1 test2
\end{lstlisting}
creates both \texttt{test1} and \texttt{test2} in the current working directory.

To create a file containing a single line of text, the \verb|echo| command with \verb|>| redirection can be used:
\begin{lstlisting}
$ echo '<content>' > <file>
\end{lstlisting}

For example
\begin{lstlisting}
$ echo '<html><body><h1>Hello world!</h1></body></html>' > ~/test.html
\end{lstlisting}
creates a simple static HTML file named \texttt{test.html} in the user home directory that displays ``Hello world!'' when opened in a browser. 

Be aware that using \verb|>| overwrites the file if it already exists. To append to an existing file, use \verb|>>| instead. For appending multiple lines, use a here-document
\begin{lstlisting}
$ cat >> <file> << "EOF"
<body>
...
EOF
\end{lstlisting}
where \verb|EOF| is used as the end mark in the example, and practically it can be any string that does not appear in the body of the text.

Similar with \verb|touch|, use \verb|mkdir| followed by the path of the directory to create a directory as follows.
\begin{lstlisting}
$ mkdir [OPTION] <path>
\end{lstlisting}
Specifically, \verb|-p| option of \verb|mkdir| allows it to create nested directories along the given path if the directories do not exist.

To move a file or a directory from an existing directory to another, use \verb|mv| command as follows.
\begin{lstlisting}
$ mv [<option>] <source> <target>
\end{lstlisting}
Different from the conventional cut-and-paste, while moving the item, it is possible to also rename the item simultaneously. For example,
\begin{lstlisting}
$ mv ~/dog.png ~/Pictures/puppy.png
\end{lstlisting}
will not only move the file \verb|dog.png| in the home directory to the subdirectory \verb|Pictures|, but also chance the file name to \verb|puppy.png|. For this reason, \verb|mv| can also be used to rename an item rather than moving the item, just by ``move'' it to the same directory but with a different name.

Some commonly used arguments of \verb|mv| is summarized in Table \ref{ch:fm:tab:mvcpcommandargument}, many of which handling existing file with the same name in the destination directory.

\begin{table}[!htb]
  \centering \caption{Commonly used arguments and their effects for \texttt{mv} and \texttt{cp} commands.}\label{ch:fm:tab:mvcpcommandargument}
  \begin{tabularx}{\textwidth}{lX}
    \hline
    Directory & Description \\ \hline
    \verb|-b| & Make a backup before overwrite. \\ 
    \verb|-u| & Overwrite only when source target item is newer than the target path item. \\ 
    \verb|-i| & Prompt before overwrite. \\ 
    \verb|-f| & Do not prompt before overwrite. \\
    \hline
  \end{tabularx}
\end{table}

The copy-and-paste command \verb|cp| works similar with the move command \verb|mv|, except that it will not remove the item from the source path. Similar syntax applies to \verb|cp| as follows, and arguments in Table \ref{ch:fm:tab:mvcpcommandargument} also apply to \verb|cp|.
\begin{lstlisting}
$ cp [<option>] <source> <target>
\end{lstlisting}

To permanently delete an item, use \verb|rm| command as follows.
\begin{lstlisting}
$ rm [<option>] <path>
\end{lstlisting}
For safety, when using \verb|rm| the OS will keep prompting messages asking user to confirm whether to permanently delete an item. In some OS setups, it is by default forbidden to delete a directory unless it is empty. The following arguments in Table \ref{ch:fm:tab:rmcommandargument} can be used to temporarily change the behavior.

\begin{table}[!htb]
  \centering \caption{Commonly used arguments and their effects for \texttt{rm} command.}\label{ch:fm:tab:rmcommandargument}
  \begin{tabularx}{\textwidth}{lX}
    \hline
    Directory & Description \\ \hline
    \verb|-f| & Ignore nonexistent files and arguments and do not prompt. \\ 
    \verb|-r| & Remove directories and their contents recursively. \\ 
    \verb|-i| & Prompt before every removal. \\ 
    \verb|-d| & Remove empty directories. \\
    \hline
  \end{tabularx}
\end{table}

It is possible though, that removed items using \verb|rm| be recovered by expertise. For greater assurance that the deleted contents are truly unrecoverable, consider using \verb|shred| which can physically overwrite the portion of hardware drive where the item is located. More details of \verb|shred| can be found by
\begin{lstlisting}
$ shred --help
\end{lstlisting}

\subsection{Wildcard Characters}

When performing actions such as listing, moving, copying, removing, wildcard characters can be used in the path. For example, \verb|ls a*| lists all items in the current directory that starts with letter ``a''. Commonly used meta-characters are summarized in Table \ref{ch:fm:tab:metacharacters}.

\begin{table}[!htb]
  \centering \caption{Commonly used wildcard characters.}\label{ch:fm:tab:metacharacters}
  \begin{tabularx}{\textwidth}{lX}
    \hline
    Directory & Description \\ \hline
    \verb|*| & Matches any number of characters. \\ 
    \verb|?| & Matches one character. \\ 
    \verb|[...]| & Matches characters given in the square bracket, which can include a hyphen-separated range of characters. \\
    \hline
  \end{tabularx}
\end{table}

\section{Access Control List} \label{ch:fm:sec:accesscontrollist}

Each file or directory in the Linux OS is assigned with an owner and a permission list known as the \mync{Access Control List}[ACL]. ACL prevents unauthorized entities from accessing an item illegally. The ACL of a file can be viewed using \verb|ls -l|. An example has been given in Fig. \ref{ch:fm:fig:lscommandexample} in the earlier section.

The first column of the output in Fig. \ref{ch:fm:fig:lscommandexample} gives the type and permission of the item. The leading \verb|d| and \verb|-| indicate subdirectory and regular file respectively. Other commonly seen indicators are \verb|l| for a symbolic link, \verb|b| for a block device, \verb|c| for a character device, \verb|s| for a socket and \verb|p| for a named pipe.

Following the item type, the ACL of the item is given in the form of 9-bit permission that looks like \verb|rwxrwxrwx|. The characters \verb|r|, \verb|w| and \verb|x| stand for three types of permissions ``read'', ``write'' and ``execute'' respectively. An explanation to these permissions is summarized in Table \ref{ch:fm:tab:threepermissions} and more details can be found in the \verb|ls| command manual accessible using \verb|ls --help|. The 9-bit permission of an item indicates the permissions of 3 types of users to the item, the first 3 bits the file owner, the middle 3 bits the file group, and the last 3 bits other users. If any bit in the 9-bit permission is overwritten by a dash \verb|-|, it means that the associated permission for the associated users is banned.

\begin{table}[!htb]
  \centering \caption{Three types of permissions.}\label{ch:fm:tab:threepermissions}
  \begin{tabularx}{\textwidth}{lX}
    \hline
    Directory & Description \\ \hline
    \verb|r| & View what is in the file or directory. \\ 
    \verb|w| & Change file contents; rename file; delete file. Add or remove files or subdirectories in a directory. \\ 
    \verb|x| & Run a file as a program. Change to the directory as the current directory; search through the directory; access metadata (file size, etc.) of files in the directory. \\
    \hline
  \end{tabularx}
\end{table}

Commands \verb|chown| and \verb|chmod| can be used to change the ownership and ACL of an item respectively. Details are given in the following subsections.

\subsection{Change of Ownership} \label{sec:chown}

Administrative privileges are required to run the \verb|chown| command, which changes the ownership and group of a file or directory:
\begin{lstlisting}
# chown [<option>] <new_owner>[:<new_group>] <file>
\end{lstlisting}

For example,
\begin{lstlisting}
$ sudo chown root:root calculate_fib.sh
\end{lstlisting}
changes the ownership and group of the file \verb|calculate_fib.sh| from \verb|sunlu| to \verb|root|. Elevated privileges are required; otherwise, the request will be rejected.

\subsection{Change of Permissions} \label{sec:chmod}

Both the owner and users with administrative privileges can change the permissions of a file or directory using \verb|chmod|:
\begin{lstlisting}
$ chmod [<option>] <new_mode> <path>
\end{lstlisting}

The new mode can be expressed symbolically. For example, \verb|g-w| removes write permission from the group while leaving other permissions unchanged. Similarly, \verb|go+w| adds write permission to both group and others. Here, \verb|u|, \verb|g|, and \verb|o| represent ``user'' (owner), ``group,'' and ``others,'' while \verb|r|, \verb|w|, and \verb|x| stand for ``read,'' ``write,'' and ``execute.''

Alternatively, a $3$-digit octal number can represent permissions. For example, \verb|664| corresponds to the following.
\begin{itemize}
  \item First digit (\verb|6| = binary \verb|110|): user permissions \verb|rw-|
  \item Second digit (\verb|6| = binary \verb|110|): group permissions \verb|rw-|
  \item Third digit (\verb|4| = binary \verb|100|): others permissions \verb|r--|
\end{itemize}
Hence, \verb|664| assigns permissions \verb|rw-rw-r--| to the file.


\subsection{Change Default Permissions}

The default ACL for a newly created file or directory is defined by \verb|umask|. Check its value by
\begin{lstlisting}
$ umask
\end{lstlisting}
And change its value temporarily in the opening shell by
\begin{lstlisting}
$ umask <new value>
\end{lstlisting}

The value of \verb|umask|, after converting to binary, represents the bits in the 9-bit permission system that is disabled. For example, a \verb|umask| value of \verb|002| represents \verb|rwxrwxr-x| in the 9-bit permission system, because the binary form of \verb|002|, \verb|000000010|, blocks the $8$-th bit in the permission.

The default \verb|umask| values for the root and the regular users in RHEL are \verb|002| and \verb|022| respectively. This is defined in \verb|/etc/bashrc|. A user can permanently change the default value of \verb|umask| by overwriting its value in \verb|.bashrc| as introduced in Section \ref{ch:sb:subsec:customizeshell}.

\section{Location of Command and File}

The most frequently used 3 searching actions are as follows.
\begin{itemize}
  \item Look for the location of a command using its name
  \item Look for the location of a file using its name (and other metadata such as size, permission, etc.)
  \item Look for the location of a file using a portion its content
\end{itemize}

Many approaches can be used to achieve the goals, some of which are introduced as follows.

\subsection{Location of Command}

Use \verb|type| to look for a command as follows.
\begin{lstlisting}
$ type <command>
\end{lstlisting}

For example
\begin{lstlisting}
$ type cd
cd is a shell builtin
$ type python
python is /usr/bin/python
$ type ls
ls is aliased to `ls --color=auto'
\end{lstlisting}

\subsection{Location of File}

The package \verb|mlocate| can be installed to enable the \verb|locate| command, which quickly searches for files by path. As long as a file or directory’s full path contains the search term, it may appear in the results.
\begin{lstlisting}
$ sudo dnf install mlocate
$ sudo updatedb
$ locate <file or path fragment>
\end{lstlisting}
Here, \verb|updatedb| must be run once after installing \verb|mlocate| to initialize the database.

The mechanism of \verb|locate| works as follows. The system periodically runs \verb|updatedb| (usually once per day) to refresh an internal database containing file names and paths. The \verb|locate| command searches this database rather than the live filesystem, making it very fast. However, this means that newly created files may not be found until the database is updated. Furthermore, not all files are included by default; the configuration file \verb|/etc/updatedb.conf| determines which paths are scanned and which are excluded. The first run of \verb|updatedb| may take some time, since it must index the entire filesystem.

Users may be confused by the commands \verb|locate| and \verb|mlocate|. In practice, they are nearly identical for basic usage. On many systems, \verb|locate| is provided as a wrapper or alias for \verb|mlocate|. In the scope of this discussion, no distinction is made between them.

For security and privacy reasons, \verb|locate| only shows files that the invoking user has permission to access. For example, a regular user cannot use \verb|locate| to see files under \verb|/root| or in another user’s home directory.

A more widely adopted way of looking for a file by its variety of attributes is using \verb|find| as follows.
\begin{lstlisting}
$ find [<options>] [<path>] <expression>
\end{lstlisting}

The \verb|<options>| argument can be used to configure how the symbolic links should be handled. With default option \verb|-P|, the symbolic links are treated as the links themselves but not the files they are linking to, whereas \verb|-L| does the opposite. Debugging modes and query optimization can also be enabled from \verb|<options>|. The \verb|<path>| argument specifies the directory from where the query is conducted. The \verb|<expression>| argument specifies the keyword and the query method.

The following are examples of using \verb|find| in different scenarios. The examples are taken from RedHat at \cite{redhat2022find}.

\vspace{0.1in}
\noindent \textbf{Find Files by Name}
\vspace{0.1in}

Use \verb|-name| or \verb|-iname| to search files by their names as follows. Case sensitive
\begin{lstlisting}
$ find / -name "*Foo*txt" 2>/dev/null
/home/seth/Documents/Foo.txt
\end{lstlisting}
Case insensitive
\begin{lstlisting}
$ find / -iname "*Foo*txt" 2>/dev/null
/home/seth/Documents/Foo.txt
/home/seth/Documents/foo.txt
/home/seth/Documents/foobar.txt
\end{lstlisting}

Wildcards such as \verb|*| can be used. Commonly used wildcards are given in Table \ref{ch:fm:tab:metacharacters}.

\vspace{0.1in}
\noindent \textbf{Find Files by Content}
\vspace{0.1in}

Use \verb|-exec| followed by \verb|grep| to find files with specific contents.
\begin{lstlisting}
$ find ~/Documents/ -name "*txt" -exec grep -Hi penguin {} \;
/home/seth/Documents/Foo.txt:I like penguins.
/home/seth/Documents/foo.txt:Penguins are fun.
\end{lstlisting}
where \verb|-exec| allows executing a command to the findings. Notice that \verb|grep| by itself can also be used to search files by contents.

\vspace{0.1in}
\noindent \textbf{Find Files by Type}
\vspace{0.1in}

Use \verb|-type| to filter files by their types. To find all files,
\begin{lstlisting}
$ find ~ -type f
/home/seth/.bash_logout
/home/seth/.bash_profile
/home/seth/.bashrc
/home/seth/.emacs
/home/seth/.local/share/keyrings/login.keyring
/home/seth/.local/share/keyrings/user.keystore
/home/seth/.local/share/gnome-shell/gnome-overrides-migrated
\end{lstlisting}
Specifically, to find empty files,
\begin{lstlisting}
$ find ~ -type f -empty
random.idea.txt
\end{lstlisting}

To find all subdirectories,
\begin{lstlisting}
$ find ~/Public -type d
find ~/Public/ -type d
/home/seth/Public/
/home/seth/Public/example.com
/home/seth/Public/example.com/www
/home/seth/Public/example.com/www/img
/home/seth/Public/example.com/www/font
/home/seth/Public/example.com/www/style
\end{lstlisting}

Use \verb|-maxdepth| to set the searching depth as follows.
\begin{lstlisting}
$ find ~/Public/ -maxdepth 1 -type d
/home/seth/Public/
/home/seth/Public/example.com
\end{lstlisting}

\vspace{0.1in}
\noindent \textbf{Find Files by Timestamp}
\vspace{0.1in}

To find files whose latest modified time is at least 30 days ago (30 days ago or earlier), use
\begin{lstlisting}
 find /var/log -mtime +30
\end{lstlisting}
where \verb|-atime|, \verb|-ctime| and \verb|-mtime| search based on the number of days since each file was accessed, changed or had its metadata changed respectively. The alternatives \verb|-amin|, \verb|-cmin| and \verb|-mmin| work similarly in minutes. The \verb|+| indicates ``at least'' whereas \verb|-| indicates ``not more than''.

\section{File Archive}

The \verb|tar|, \verb|gzip| and \verb|zip| commands can all be used for files archive. Each of them has unique features as given in Table \ref{ch:fm:tab:filearchivetools}.

\begin{table}[!htb]
	\centering \caption{Commonly used file archive tools.}\label{ch:fm:tab:filearchivetools}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Directory & Description \\ \hline
		\verb|tar| & Save many files together into a single tape or disk archive, and can
		restore individual files from the archive. By default, it does not compress the files. However, \verb|-z| option can be used in combination of the command to add compression feature. \\ 
		\verb|gzip| & Compress or restore files. \\ 
		\verb|zip| & Compress multiple files one-by-one and integrate them together into a single file. \\
		\hline
	\end{tabularx}
\end{table}

Only \verb|tar| command is introduced here, as it is the most commonly used one among the three, and it can satisfy most use cases. A common way of using \verb|tar| is as follows. Use
\begin{lstlisting}
$ tar -cvzf <archive-file> <file1> <file2> <file3> ...
\end{lstlisting}
to archive and zip files, and
\begin{lstlisting}
$ tar -xvzf <archive-file>
\end{lstlisting}
to restore files from the archive file. The commonly used archive file name, in this scenario, is \verb|<filename>.tgz|.

The detailed explanation to all available options for \verb|tar| can be found using \verb|tar --help|. The most commonly used options are \verb|-c|, \verb|-x|, \verb|-z|, \verb|-f| and \verb|-v|, standing for creating compress tape, extracting (restoring) file, adding compressing feature, using file archive, and listing processed files in the console, respectively.
