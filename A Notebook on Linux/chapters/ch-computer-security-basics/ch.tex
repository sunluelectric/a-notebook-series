\chapter{OS Security Mechanism}

Linux as well as other OS uses variety of methods to protect system and data security. This chapter and next few chapters introduces these security methods. As cloud computing is getting more and more popular, the chapters also discuss the security in virtualization.

\section{Basic Concepts}

The background and basic concepts of computer security are introduced in this section.

\subsection{Risks and Attacks}

No computer or OS are absolutely safe. Some risks are listed below.
\begin{itemize}
	\item Software bugs. The OS and application software may have bugs which leave backdoors to malware.
	\item Malicious users. A user may perform illegal actions that damage other users sharing the same servers or services.
	\item Unauthorized access. The user or a program may intentionally or accidentally try to access data confidential to them.
\end{itemize}
A risk, if not attended, will most likely not turn into an actual damage. However, when a hacker or a malicious user initiate an attack using the risk, it may cause trouble.

The attacks can be divided into the following categories.
\begin{itemize}
	\item Malware. The attacker disguises a piece of malware code as a legitimate software. When the software is executed, the malware carries out harmful activities.
	\item System Penetration. The attacker accesses a protected system bypassing security mechanisms.
	\item Man-in-the-Middle Attack (MitM). The attacker intercepts communications between entities, and steal or modify the contents of the communication.
	\item Denial of Service (DoS). The attacker overwhelms a system and paralyzes its service by sending a lot of requests to the system, more than it can handle.
	\item Network Sniffing. The attacker passively logs information from the internet, and use them for future attacks.
	\item TEMPEST (Van Eck phreaking). The attacker collects and analyses data measured from electromagnetic emissions of devices such as mobile phones, and decode information from the measurements.
	\item Social Engineering. The attacker gathers information of the victims by cheating, phishing emails, etc. 
\end{itemize}

To protect the users from the attacks, we need both computer security and communication security. This chapter focuses on computer security, specifically OS security.

\subsection{General Security Architecture}

Linux machine layers are shown in Fig. \ref{ch:ossec:fig:layerstructure}. Machines of other OS may adopt a different structure, but the essence remains similar. It is impractical to secure every component of a system (hardware, OS kernel, OS services, application services, user interface, users, etc.) with a singular universal protection method.

\begin{figure}
	\centering
	\includegraphics[width=200pt]{chapters/ch-computer-security-basics/figures/os_layer.png}
	\caption{Layer structure of an operating system.} \label{ch:ossec:fig:layerstructure}
\end{figure}


A more widely accepted approach is to implement a layered security architecture. In this paradigm, the system is segregated into distinct layers such as the hardware layer, the OS layer, and the application layer. Each layer employs its own security mechanisms targeting specific vulnerabilities.

Among all these layers, securing the OS is particularly crucial for several reasons:
\begin{itemize}
	\item Breaches in both hardware and application software often exploit vulnerabilities within the OS. By securing the OS, threats to other layers can be substantially mitigated. Even if certain applications are compromised, a robust OS can limit the extent and spread of the damage.
	\item If the OS is compromised, safeguarding other layers becomes extremely difficult. Most components across layers interact frequently with the OS and they typically operate under the assumption that the OS is trustworthy.
\end{itemize}

A system is considered secure if the following criteria are met.
\begin{itemize}
	\item It is secure upon booting, and
	\item It never perform an action so that it can become insecure from a secure condition. 
\end{itemize}
Notice that just for clarification, there are some slight differences between two terminologies, ``secure'' and ``trusted'' as follows. System security is the ultimate goal. A system is either secure or insecure, and we want it to stay secure all the time. Trustworthy, on the other hand, is a graded feature that we use to describe an entity in the system. We can, for example, say which parts (services, users, etc.) of the system is trustworthy, and to what extent they can be trusted.

\subsection{Standards and Requirements}

There are many official standards on computer security. For example, Trusted Computer System Evaluation Criteria (TCSEC) published in 1985, also known as the ``orange book'', is one of the earliest standards in this domain. It divides system into different tiers in terms of security, including
\begin{itemize}
	\item A: Verified protection
	\item B: Mandatory protection
	\begin{itemize}
		\item B3: Security Domains
		\item B2: Structured Protection
		\item B1: Labeled Security Protection
	\end{itemize}
	\item C: Discretionary protection
	\begin{itemize}
		\item C2: Controlled Access Protection
		\item C1: Discretionary Security Protection
	\end{itemize}
	\item D: Minimal protection
\end{itemize}
Notice that TCSEC is considered outdated due to the rapid advancement of technology. Nowadays, commercialized PCs and OS such as Windows 11 pro, MacOS, RHEL, implement robust security mechanisms that align with various aspects of TCSEC criteria of different tiers, some of which required by Tier B and even Tier A. While TCSEC remains a classic and milestone, newer standards have been developed and adopted globally by various countries and organizations.

In the scope of Linux, there is an open-project, ``Security Enhanced Linux (SELinux)'' that enables mandatory access control in Linux. It started as an add-on module built into the Linux kernel, and today it has become a default module built-in to all Linux distributions.

In general, the requirements of secure computer systems include
\begin{itemize}
	\item Confidentiality. Data, as well as the existence of the data, is not leaked to unauthorized entities.
	\item Integrity. The data can be trusted, and it cannot be modified by unauthorized entities.
	\item Accountability. It is possible to trace and audit the actions performed by users and programs.
	\item Availability. The system should be resistant to attacks and consistently provide services.
\end{itemize} 
The primary objective of studying computer security is to ensure that the aforementioned requirements are consistently met and upheld. Regrettably, there is no systematic approach guaranteeing that these requirements are met at all times.

\section{Elements of Security}

Key components of security under study include:
\begin{itemize}
	\item Security policy. It defines what needs to be protected and what the desired security outcomes are.
	\item Security mechanism. It defines the tools, methods, and procedures employed to enforce the security policy.
	\item Security assurance: It defines the means by which we evaluate the efficacy of the security mechanism.
\end{itemize}

\subsection{Security Policy}

A security policy establishes the standards and objectives that a system must adhere to, outlining the rules that both users and programs are expected to follow. Deviations from these stipulations or breaches of the rules can compromise the security of the system. It's important to note that a security policy often comprises a set of sub-policies, which may be categorized into areas like confidentiality policies, integrity policies, and so on.

For the sake of clarity and to ensure no misunderstandings arise, it's crucial for the security policy to be articulated in a precise and consistent manner. Instead of relying on colloquial or vague terminology, it's advisable to describe the security policy using more abstract or formalized methods. We use security policy model to formally and precisely describe the security policy. Security policy model should be ambiguity-free and easy to comprehend. Though it does not assume or restrict the security mechanism to be used to realize the policy, it should give some guidance to how the mechanisms can be designed. At the minimum, it should make sure that there is such security mechanism that can fulfill the policy.

\subsection{Security Mechanism}

















\section{Access Control}

In the realm of computer security, a ``subject'' denotes an active entity that initiates an action, typically a user who takes an active role. On the other hand, an ``object'' represents a passive entity that receives or is acted upon by the action. In most contexts, objects are files, data, or programs. Processes and threads can simultaneously act as both subjects and objects.

The term ``access'' is used to describe when a subject performs actions on an object. This can encompass various activities such as creating, reading, executing, editing, or deleting the object.

Access control is a mechanism that assists systems in determining whether to grant or deny specific permissions, dictating which subjects can access particular objects and what actions they can undertake with those objects. Typically, a user who plays subject is required to identify themselves by logging into the system using a valid authentication method as a prerequisite. A program that plays subject needs to be assigned with a ``role''. The program can only execute if its role possesses the necessary permissions to do so, including access to required resources like CPU, memory, disk space, and databases.

We use access control matrix to describe the association of subject and object. A demonstrative graph is given in Fig. \ref{ch:ossec:fig:acmatrix}. In this demonstration, the same ``read'', ``write'' and ``execute'' permissions as introduced in Section \ref{ch:fm:sec:accesscontrollist} are used.

\begin{figure}
	\centering
	\includegraphics[width=300pt]{chapters/ch-computer-security-basics/figures/acmatrix.png}
	\caption{A demonstration of access control matrix.} \label{ch:ossec:fig:acmatrix}
\end{figure}















