%\chapterauthor{Author Name}{Author Affiliation}
%\chapterauthor{Second Author}{Second Author Affiliation}
\chapter{Database}

Database and its manage systems are introduced in this chapter. SQL is introduced. Both relational and non-relational databases are used as examples to demonstrate how database can be used on a Linux system.

\section{Introduction to Database}

Database, in a broad view, refers to an organized collection of data of any format. In this sense, any file format that hosts information in an meaningful and explainable way, such as \textit{csv}, \textit{XML}, or \textit{JSON}, is a database. These file formats often work fine when the data is stored in a centralized manner and its size small.

As the data size grows, the robustness and efficiency of data storage and retrieval may become an issue. Therefore, different database models have been proposed for more robust and efficient data storage and retrieval. Dedicated software, namely the database management systems (DBMS), are developed to manage and maintain the database and provide an interface for the users to create, retrieve, update and delete data. Different database models require different database engines and different types of DBMS.

There are hundreds of database models and engines available in the market. In general, the most widely seen database models can be divided into two categories, namely the relational databases (RDS) and the non-relational databases.

Relational databases proposed in 1980s use rows and fixed columns in a series of fixed tables to store data. The tables are related to each other via shared columns. RDS is intuitive and efficient in most occasions. Structured query language (SQL), a domain-specific language, is used in managing RDS and interfacing relational DBMS.

Non-relational databases proposed in 2000s, on the other hand, usually store data in key-value pairs instead of tables. A widely acknowledged non-relational database storage format is \textit{JSON}.

Non-relational databases can be very fast in query, and are becoming popular in handling big data and in real-time web applications. However, many non-relational databases compromise consistency issue, and can only provide ``eventual consistency'', which implies that the latest update in the non-relational database may not be reflected in an immediate query. Non-relational databases can be accessed by NoSQL, a collective set of languages dedicated for non-relational database management.

Unlike SQL which applies to almost all RDS, there is no universally adopted language for NoSQL.

In this chapter, both relational and non-relational databases are introduced in further details to illustrate the database service on a Linux system. In particular, SQL is also briefly introduced as it is a very important subject in managing a relational database.

\section{Relational Database and SQL}

Relational database is so far the most commonly used digital database. Details are given in the rest of the section.

\subsection{Brief Introduction to Relational Database}

Relational database is proposed in 1970s by IBM. Some important features of a relational database includes the following.
\begin{itemize}
  \item Structure the data as ``relations'', which is a collection of tables, each consisting of a set of rows (also known as tuple/record) and columns (also known as attribute/field).
  \item Provide relational operations the manipulate the data in the tables, for example, joining tables together and aligning them using an attribute.
\end{itemize}

Examples of relational databases include \textit{Oracle}, \textit{MySQL}, \textit{Microsoft SQL Server}, \textit{MariaDB}, \textit{IBM Db2}, \textit{Amazon Redshift} and \textit{Amazon Aurora}. Most commercialized relational databases adopt SQL as the query language. There are alternative languages, but are rarely used compared to SQL.

\subsection{Tables} \label{ch:db:subsec:tables}

An example of a table used in RDS is given in Table \ref{ch:db:tab:relationaldbexample}, where the table has a name as the identifier, \verb|user|. In this table, there are 5 attributes, namely \verb|user_id|, \verb|user_password_sha256|, \verb|user_email|, \verb|membership| and \verb|referee_id|.

A table should have an attribute (or a set of attributes) defined as the primary key. In the example given by Table \ref{ch:db:tab:relationaldbexample},  \verb|user_id| as denoted by the asterisk. The primary key is used to uniquely identify a row in the table. When a key is made up of multiple attributes, it is called a composite key.

The primary key can be either a surrogate key, which is generated by the table for recording purpose and is not derived from application data (for example, product serial id, etc.), or a natural key, which reflects meaningful information in real world (for example, email, citizenship IC number, etc.).

\begin{table}
	\centering \caption{An example of a relational database table.}\label{ch:db:tab:relationaldbexample}
	\begin{tabular}{|c|c|c|c|c|}
		\hline
        \multicolumn{5}{|c|}{user} \\ \hline
		\verb|user_id|$^*$ & \verb|user_password_sha256| & \verb|user_email| & \verb|membership| & \verb|referee-id| \\ \hline
        sunlu & xxxxxxxx & sunlu@xxx.com & premium & NULL \\ \hline
        xingzhe & yyyyyyyy & xingzhe@yyy.com & basic & sunlu \\ \hline
        \ldots & \ldots & \ldots & \ldots & \ldots \\ \hline
	\end{tabular}
\end{table}

A foreign key is the attribute(s) that link a table to another table. It is the primary key of another table that in someway connects to this table. For example, the \verb|membership_type| attribute in Table \ref{ch:db:tab:relationaldbexample} could be the foreign key that links to another Table \ref{ch:db:tab:relationaldbexampleanother}. Notice that a foreign key doe not necessarily need to have the same name as the primary key in another table (though their links are there), it is a good practice to keep them consistent.

\begin{table}
	\centering \caption{A second database table in the example.}\label{ch:db:tab:relationaldbexampleanother}
	\begin{tabular}{|c|c|c|}
		\hline
        \multicolumn{3}{|c|}{membership} \\ \hline
		\verb|membership_type| & \verb|monthly_price| & \verb|annual_price| \\ \hline
        none & 0 & 0 \\ \hline
        basic & 5 & 50 \\ \hline
        premium & 10 & 80 \\ \hline
	\end{tabular}
\end{table}

A table can have only one primary key, but can have multiple foreign keys. The foreign key can not only relate a table to another, but can also relate a table to itself. For example, the ``referee-id'' attribute in Table \ref{ch:db:tab:relationaldbexample} could be the foreign key that relates to ``user-id'' of itself, from which we know that user the referee of user ``xingzhe'' is user ``sunlu''.

Primary key and foreign keys designs form the database schema. They together defines and describes the tables and relations between them.

Naming conventions shall apply to the databases, tables and columns. Some rules and good practices are concluded as follows.
\begin{itemize}
\item Use natural collective terms instead of plurals. For example, ``staff'' but not ``employees''.
\item Use only letters, numbers, and underscores.
\item Begin with a letter and may not end with an underscore.
\item Avoid using abbreviations unless commonly understood.
\item Avoid using prefixes.
\item Table:
\begin{itemize}
	\item Do NOT use the same name for a table and one of its columns.
	\item Do NOT concatenate two table names to create a third relationship table.
\end{itemize}
\item Column:
\begin{itemize}
	\item Use singular name for columns.
	\item Avoid using over simplified terms such as ``id''.
	\item Use only lowercase if possible.
\end{itemize}
\item Alias:
\begin{itemize}
	\item Use keyword AS to indicate an alias.
	\item The correlation name should be the first letter of each word of the object name.
	\item If there is already the same correlation name, append a number.
\end{itemize}
\item Stored procedure. Always contain a verb in the name of a stored procedure.
\item Uniform suffixes:
\begin{itemize}
	\item \verb|_id|: primary key.
	\item \verb|_status|: flag values.
	\item \verb|_total|: the total number of a collection of values.
	\item \verb|_num|: a number.
	\item \verb|_date|: a date.
	\item \verb|_name|: the name of a person or product.
\end{itemize}
\end{itemize}

\subsection{SQL}

SQL is the most widely language for interacting with relational DBMS for data query and maintenance. SQL is very powerful and flexible in its full capability. In this section, only the basic SQL operations are introduced.

Notice that there might be slight differences in the SQL for different DBMS, depending on their associated unique features. Most of the commands, especially the widely used ones, shall be universally consistent.

SQL is a hybrid language consisting of the following 4 types of languages.
\begin{itemize}
  \item Data query language: query information and metadata of a database.
  \item Data definition language: define database schemas.
  \item Data control language: control user access and permission to a database.
  \item Data manipulation language: insert, update and delete data from a database.
\end{itemize}

SQL supports variety of data types, and different DBMS may cover slightly different data types. Some of the most commonly used data types are summarized in Table \ref{ch:db:tab:sqldatatypes} and they shall be universally consistent. For the full list of data types that a DBMS supports, check the manuals and documents of that DBMS.

\begin{table}
	\centering \caption{Widely used SQL data types.}\label{ch:db:tab:sqldatatypes}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Data Type & Description \\ \hline
		INT/INTEGER & Integer, with a range of -2147483648 to 2147483647. When marked ``UNSIGNED'', the range becomes 0 to 4294967295. Some relevant data types are TINYINT, SMALLINT, MEDIUMINT, and BIGINT, which have a different range. \\ \hdashline
		DEC/DECIMAL(size,d) & An exact fixed-point number. The total number of digits and the number of digits after decimal point are specified by ``size'' and ``d'', respectively. Some relevant data types are DOUBLE(size,d), which can also be used to specify a floating point. Notice that DEC/DECIMAL is usually preferable in most occasions. \\ \hdashline
		CHAR(size) & A fixed length string with the specified length in characters. \\ \hdashline
		VARCHAR(size) & A variable length string, with the specified maximum string length in characters. \\ \hdashline
		BOOL/BOOLEAN & This is essentially a 1-digit integer, where 0 stands for ``false'' and other values stand for ``true''. \\ \hdashline
		BLOB & A binary large object with maximum 65535 bytes. \\ \hdashline
		DATE & A date by format ``YYYY-MM-DD''. \\ \hdashline
		TIME & A time by format ``hh:mm:ss''. \\ \hdashline
		DATETIME & A combination of date and time by format ``YYYY-MM-DD hh:mm:ss''. \\ \hdashline
		TIMESTAMP & A timestamp that measures the number of seconds since the Unix epoch. The format is ``YYYY-MM-DD hh:mm:ss''. Unlike DATETIME, TIMESTAMP specifies an exact point in time, thus is not affected by timezone, etc. \\ \hline
	\end{tabularx}
\end{table}

SQL defines reserved keywords for database manipulation. The keywords have specific meanings and cannot be used as user-defined variable names. Commonly used SQL keywords are summarized in Tables \ref{ch:db:tab:sqlkeywords1}, \ref{ch:db:tab:sqlkeywords2} and \ref{ch:db:tab:sqlkeywords3}.

\begin{table}
	\centering \caption{Widely used SQL keywords (part 1: names).}\label{ch:db:tab:sqlkeywords1}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Keyword & Description \\ \hline
		CONSTRAINT & A constraint that limits the value of a column. \\ \hdashline
		DATABASE & A database. \\ \hdashline
		TABLE & A table. \\ \hdashline
		COLUMN & A column (attribute, field) of a table. \\ \hdashline
		VIEW & A view, which is a virtual table which does not store data by itself and only reflects the base tables data. \\ \hdashline
		INDEX & An index, which is a pre-scan of specific column(s) of a table and can be used to speed up future queries related to the column(s). Notice that unlike a view, an index needs to be stored together with the table. \\ \hdashline
		PRIMARY KEY & The primary key of a table. \\ \hdashline
		FOREIGN KEY & A foreign key defined in a table that links to a (different) table. \\
		PROCEDURE & A procedure that defines a list of database operations to be executed one after another \\ \hline
	\end{tabularx}
\end{table}

\begin{table}
	\centering \caption{Widely used SQL keywords (part 2: actions).}\label{ch:db:tab:sqlkeywords2}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Keyword & Description \\ \hline
		CREATE & Create a database (CREATE DATABASE), a table (CREATE TABLE), an index (CREATE INDEX), a procedure (CREATE PROCEDURE). \\ \hdashline
		ADD & Add a column in an existing table, or a constraint to an existing column. \\ \hdashline
		ALTER & Modify columns in a table (ALTER TABLE), or a data type of a column (ALTER COLUMN). \\ \hdashline
		SET & Specify the columns and values to be updated in a table. \\ \hdashline
		DROP & Delete a column (DROP COLUMN), a constraint (DROP CONSTRAINT), a database (DROP DATABASE), an index (DROP INDEX), a table (DROP TABLE), or a view (DROP VIEW). \\ \hdashline
		CHECK & Define a constraint that limits the value that can be placed in a column. \\ \hdashline
		DEFAULT & Define a default value for a column. \\ \hdashline
		INSERT INTO & Insert a new row into a table. \\ \hdashline
		UPDATE & Update an existing row (tuple, entity) in a table. \\ \hdashline
		DELETE & Delete a row (tuple, entity) from a table. \\ \hdashline
		EXEC & Executes a stored procedure. \\ \hline
	\end{tabularx}
\end{table}

\begin{table}
	\centering \caption{Widely used SQL keywords (part 3: queries).}\label{ch:db:tab:sqlkeywords3}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Keyword & Description \\ \hline
		SELECT & Query data from a database. Relevant combinations are SELECT DISTINCT which returns only distinct values; SELECT INTO which copies data from one table into another; SELECT TOP which returns part of the results. \\ \hdashline
		AS & Assign an alias to a column or table. \\ \hdashline
		FROM & Specify the table where the operation is run. \\ \hdashline
		WHERE & Filter results that fulfill a specified condition. \\ \hdashline
		IN & Specify multiple values in a WHERE clause. \\ \hdashline
		AND & Select rows where both conditions are true. \\ \hdashline
		OR & Select rows where either condition is true. \\ \hdashline
		ALL & Return true if all followed sub-query values meet the condition. \\ \hdashline
		ANY & Return true if any followed sub-query value meet the condition. \\ \hdashline
		BETWEEN & Select values within a given range. \\ \hdashline
		ORDER BY & Sort the results in ascending or descending order. \\ \hdashline
		JOIN & Join tables for query. Relevant combinations are OUTER JOIN, INNER JOIN, LEFT JOIN and RIGHT JOIN. \\ \hdashline
		EXISTS & Tests for the existence of any record in a sub-query. \\ \hdashline
		GROUP BY & Groups the result set when using aggregate functions (COUNT, MAX, MIN, SUM, AVG). \\ \hdashline
		UNION & Combines the result sets of multiple select statements. \\
		 \hline
	\end{tabularx}
\end{table}

\vspace{0.1in}
\noindent \textbf{General Rules}
\vspace{0.1in}

All SQL commands shall end with a semicolon ``\verb|;|''.

The programming of SQL shall follow the following general rules wherever possible. This helps to maintain the good quality and portability of the code.
\begin{itemize}
	\item Use standard SQL functions instead of vendor-specific functions for better portability.
	\item Do NOT use object-oriented design principles in SQL or database schema.
	\item Use UPPERCASE for keywords.
	\item Use \verb|/*<comments>*/| to add comments to the code, otherwise precede comments with \verb|-- <comments>| and finish them with a new line.
\end{itemize}

The naming of database, tables and columns shall follow conventions introduced in Section \ref{ch:db:subsec:tables}.

During the coding, follow the following rules.
\begin{itemize}
	\item Use spaces to align the codes.
	\item Use a space before and after equals (=), after commas (,).
	\item Use BETWEEN and IN, instead of combining multiple AND and OR clauses.
\end{itemize}

When creating a table, follow the following rules.
\begin{itemize}
	\item Choose standard SQL data types.
	\item Specify default values and set up constraints, and put them close to the declaration of the associated column name.
	\item Select primary key carefully and keep it simple.
	\item Specify the primary key first right after the CREATE TABLE statement.
	\item Implement validation. For example, for a numerical value, use CHECK to prevent incorrect values.
\end{itemize}

\vspace{0.1in}
\noindent \textbf{Database Manipulation}
\vspace{0.1in}

To list down all the databases running on the server, use
\begin{lstlisting}
SHOW DATABASES;
\end{lstlisting}

To create a database, use
\begin{lstlisting}
CREATE DATABASE <database-name>;
\end{lstlisting}

To select a database, use
\begin{lstlisting}
USE <database-name>;
\end{lstlisting}

To delete a database, use
\begin{lstlisting}
DROP DATABASE <database-name>;
\end{lstlisting}

\vspace{0.1in}
\noindent \textbf{Table Manipulation}
\vspace{0.1in}

Tables are the fundamental components in an RDS. Some features of a table have been introduced in Section \ref{ch:db:subsec:tables}. To create a commonly seen table, use
\begin{lstlisting}
CREATE TABLE <table-name> (
    PRIMARY KEY (<column-name>),
    <column-1>          <data-type>     <constraint>,
    <column-2>          <data-type>     <constraint>,
                        CONSTRAINT <constraint-name-1>
                        CHECK(<constraint-rule>),
                        CONSTRAINT <constraint-name-2>
                        CHECK(<constraint-rule>)
);
\end{lstlisting}
where notice that for demonstration purpose, 2 columns and 2 constraints are defined.

The \verb|<constraint>| that comes after the data type of a column is used to set an additional restriction to the data in the table. When such restriction is violated, an error would raise to stop the operation. For example, if \verb|NOT NULL| is set as a constraint, then when inserting a row to the table later, the user cannot input NULL for that specific column. Notice that the primary key can also be set in this way, as a constraint named \verb|PRIMARY KEY|, although it is a better practice to use \verb|PRIMARY KEY (<column-name>)|.

Commonly used such constraints are summarized into Table \ref{ch:db:tab:constraints}.
\begin{table}
	\centering \caption{Commonly used constraints.}\label{ch:db:tab:constraints}
	\begin{tabularx}{\textwidth}{lX}
		\hline
		Constraint & Description \\ \hline
		\verb|NOT NULL| & Not allowed to be NULL. \\ \hdashline
		\verb|UNIQUE| & Not allowed to have duplicated values. \\ \hdashline
        \verb|PRIMARY KEY| & Set as primary key, thus, must be not NULL and must remain unique. \\ \hdashline
        \verb|FOREIGH KEY| & Set as foreign key. \\ \hdashline
        \verb|DEFAULT <value>| & Set a default value. \\ \hdashline
        \verb|AUTO_INCREMENT = <value>| & Each time a new row is inserted and NULL or 0 is set for this column, instead of set the column to NULL or 0, automatically generate the next sequence number. The starting value is defined by \verb|<value>| which by default is 1. \\
		 \hline
	\end{tabularx}
\end{table}
As shown by Table \ref{ch:db:tab:constraints}, a default value can be assigned to a column by using the \verb|DEFAULT <value>| constraint. When inserting a new row, the column of that row will be assigned to its default value if no other value is assigned. If no such statement is provided for a column, its default value is NULL.

Upon creation of a table, its basic schema can be reviewed using
\begin{lstlisting}
DESCRIBE <table-name>;
\end{lstlisting}

To list down existing tables, use
\begin{lstlisting}
SHOW TABLES;
\end{lstlisting}

To delete a table, use
\begin{lstlisting}
DROP TABLE <table-name>;
\end{lstlisting}

To edit the column of a table, use either of the following
\begin{lstlisting}
ALTER TABLE <table-name>
ADD <column-name> <data-type>; -- add new column
ALTER TABLE <table-name>
DROP COLUMN <column-name>; -- drop column
ALTER TABLE <table-name>
RENAME COLUMN <old-name> TO <new-name>; -- rename column
ALTER TABLE <table-name>
MODIFY COLUMN <column-name> <data-type>; -- modify column data type (depending on DBMS, syntax may differ)
\end{lstlisting}
and
\begin{lstlisting}
ALTER TABLE <table-name>
ADD CONSTRAINT <constraint-name> CHECK(<constraint-rule>); -- add constraint
ALTER TABLE <table-name>
DROP CONSTRAINT <constraint-name>; -- drop constraint
\end{lstlisting}
Notice that it is possible to change the primary key of a table similarly, because essentially the primary key is treated as a constraint named ``primary''.

The foreign key is a key used to point to another table. Therefore, the foreign key can be nominated only after the other table has been created. Declare foreign key upon creation of a table as follows. As mentioned, to do this, the other tables must be created beforehand.
\begin{lstlisting}
CREATE TABLE <table-name> (
    PRIMARY KEY (<column-name>),
    <column-1>          <data-type>     <constraint>,
    <column-2>          <data-type>     <constraint>,
                        CONSTRAINT <constraint-name-1>
                        CHECK(<constraint-rule>),
                        CONSTRAINT <constraint-name-2>
                        CHECK(<constraint-rule>),
    FOREIGN KEY (<column-name>) REFERENCES <referred-table-name>(<referred-column-name>), -- one way to define foreign key
                        CONSTRAINT <constraint-name-3>
                        FOREIGN KEY (<column name>)
                        REFERENCES <referred-table-name>(<referred-column-name>) -- another way to define foreign key
);
\end{lstlisting}
where, as can be seen, foreign key is just treated as a constraint in the table.

To define a foreign key in an existing table, use
\begin{lstlisting}
ALTER TABLE <table-name>
ADD FOREIGN KEY (<column name>) REFERENCES <referred-table-name>(<referred-column-name>); -- one way
ALTER TABLE <table-name>
ADD CONSTRAINT <constraint-name> FOREIGN KEY (<column name>) REFERENCES <referred-table-name>(<referred-column-name>); -- another way
\end{lstlisting}

To drop a foreign key, use
\begin{lstlisting}
ALTER TABLE <table-name>
DROP CONSTRAINT <constraint-name>;
\end{lstlisting}
where put the constraint name associated with the foreign key at \verb|<constraint-name>|. There are variety ways of checking the constraints names of a table. An example is given below.
\begin{lstlisting}
SELECT TABLE_NAME, CONSTRAINT_TYPE, CONSTRAINT_NAME
FROM information_schema.table_constraints
WHERE table_name=<table-name>;
\end{lstlisting}

One thing to note is that upon creation of a foreign key, the referred column becomes the ``parent'' and the foreign key becomes a ``child''. As long as the child exists, the parent cannot be removed from its table. This helps to protect the schema of the database. Should there be any quest to break the schema, this restriction can be overwritten. When defining the foreign key, add an additional claim ``ON DELETE SET NULL'' or ``ON DELETE CASCADE'' as follows.
\begin{lstlisting}
FOREIGN KEY (<column name>) REFERENCES <referred-table-name>(<referred-column-name>) ON DELETE SET NULL
FOREIGN KEY (<column name>) REFERENCES <referred-table-name>(<referred-column-name>) ON DELETE CASCADE
\end{lstlisting}
in the first scenario, the child foreign key will be set to NULL, while in the second scenario, the child relevant rows will be removed.

\vspace{0.1in}
\noindent \textbf{Row Manipulation}
\vspace{0.1in}

To insert a row into a table, use
\begin{lstlisting}
INSERT INTO <table-name> VALUES (<content>, <content>, ...);
\end{lstlisting}
where the contents shall follow the field sequence as shown by the \verb|DESCRIBE <table-name>| command. To specify the column name while inserting a row, use
\begin{lstlisting}
INSERT INTO <table-name>(<column-name>, <column-name>, ...) VALUES (<content>, <content>, ...);
\end{lstlisting}
Notice that it is also possible to populate multiple rows of a table using one command as follows.
\begin{lstlisting}
INSERT INTO <table-name>(<column-name>, <column-name>, ...)
VALUES (<content>, <content>, ...),
       (<content>, <content>, ...),
       (<content>, <content>, ...);
\end{lstlisting}
where 3 rows are inserted into the table.

Notice that if a foreign key bound exists between two tables, when inserting a row to the child table, the foreign key value of this row must already be defined in the parent table.

Use the following command to query all items in a table, which can be used to check whether the row is added to the table correctly.
\begin{lstlisting}
SELECT * FROM <table-name>;
\end{lstlisting}

To modify the attributes of specific row(s), use
\begin{lstlisting}
UPDATE <table-name>
SET <column-name> = <value>, ...
WHERE <filter-criteria>;
\end{lstlisting}
where \verb|<filter-critera>| is used to filter the rows to which the update is carried out. Commonly used filter criteria are a set of \verb|<cloumn-name> = <value>| separated by \verb|AND| and \verb|OR|. The filter criteria can be set very flexibly and more details are given in later sections. Notice that it is possible to change multiple column values together, by stacking multiple \verb|<column-name> = <value>| separated by ``,''.

To delete rows from a table, use
\begin{lstlisting}
DELETE FROM <table-name>
WHERE <filter-criteria>;
\end{lstlisting}

Notice that if filter criteria is not specified, i.e., if \verb|WHERE| is missing, all items in the table will be affected.

\vspace{0.1in}
\noindent \textbf{Query}
\vspace{0.1in}

A typical query looks like the following and it returns the data in a table-like format.
\begin{lstlisting}
SELECT <column-or-statistics>
FROM <table-name-or-combination>
GROUP BY <column-name>
WHERE <filter-criteria>
ORDER BY <column-name>, ...
LIMIT <number>;
\end{lstlisting}
where
\begin{itemize}
\item \verb|<column-or-statistics>| describes the columns to be returned.
\item \verb|<table-name-or-combination>| describes the source of the information, either being a table, or a joint of multiple tables.
\item \verb|GROUP BY| groups rows with the same value of the specified column into ``summary rows''.
\item \verb|<filter-condition>| defines the filter criteria and only rows meet the criteria are returned.
\item \verb|ORDER BY <column-name>| allows the items to be returned in a specific order based on ascending/descending order. It is worth mentioning that the \verb|<column-name>| here does not need to appear in the selected returns, and it can be multiple columns separated by ``,''. Use \verb|ASC| (default) or \verb|DESC| after each \verb|<column-name>| to specify ascending or descending order.
\item \verb|LIMIT <number>| restricts the maximum number of rows to be returned.
\end{itemize}

Notice that \verb|SELECT| and \verb|FROM| statements are compulsory in all queries, \verb|WHERE| statement very widely used, and other statements optional case by case.

Details to each field are given below.

The statement \verb|<column-or-statistics>| mainly controls the information to be returned. Commonly seen selected items in \verb|<column-or-statistics>| are summarized as follows.
\begin{itemize}
  \item \verb|*| (asterisk): return all columns.
  \item \verb|<column-name>, ...|: return selected columns.
  \item \verb|<table-name>.<column-name>, ...|: return selected columns, and to avoid ambiguity, specify table name with the column name.
  \item \verb|<column-name> AS <alias>|: return selected columns, and use alias in the returns.
  \item \verb|DISTINCT <column-name>, ...|: return only distinct rows.
  \item \verb|COUNT()|, \verb|SUM()|, \verb|MIN()|, \verb|MAX()|, \verb|AVG()|: return aggregate function of a column instead of all the items in that column. They can be used along with DISTINCT, for example, \verb|COUNT(DISTINCT <column-name>, ...)|.
  \item Simple calculations to the above result, for example \verb|1.5*<column-name>|. Commonly used arithmetic operations are \verb|+|, \verb|-|, \verb|*|, \verb|/|, \verb|%|, \verb|DIV| (integer division).
\end{itemize}

The statement \verb|<table-name-or-combination>| mainly indicates the source table(s). It can be a single table, a joint of multiple tables, or a nest query. More details about joint of multiple tables are illustrated below.

Consider the following example, where two tables are given as follows.
\begin{lstlisting}
> SELECT * FROM test;
+---------+---------+---------+
| test_id | value_1 | value_2 |
+---------+---------+---------+
|       1 | a       |      10 |
|       2 | a       |      20 |
|       3 | a       |      30 |
|       4 | b       |     100 |
|       5 | b       |     200 |
|       6 | c       |    1000 |
|       7 | c       |    2000 |
+---------+---------+---------+

> SELECT * FROM test_join;
+--------------+---------+---------+---------+
| test_join_id | value_1 | value_2 | value_3 |
+--------------+---------+---------+---------+
| a            |      10 |      99 | alpha   |
| b            |     100 |     999 | bravo   |
| d            |   10000 |   99999 | delta   |
+--------------+---------+---------+---------+
\end{lstlisting}

There are different types of joins, namely ``inner join'' (or ``join''), ``left join'', ``right join'' and ``cross join''. They are introduced as follows.

The most intuitive join is the cross join. It returns everything in the two tables like a cartesian product (that explains whey cross join is also called cartesian join), where the total number of columns are the sum of two tables, the number of rows the product of two tables, as shown below.
\begin{lstlisting}
> SELECT * FROM test CROSS JOIN test_join;
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       1 | a       |      10 | b            |     100 |     999 | bravo   |
|       1 | a       |      10 | d            |   10000 |   99999 | delta   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | b            |     100 |     999 | bravo   |
|       2 | a       |      20 | d            |   10000 |   99999 | delta   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | b            |     100 |     999 | bravo   |
|       3 | a       |      30 | d            |   10000 |   99999 | delta   |
|       4 | b       |     100 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       4 | b       |     100 | d            |   10000 |   99999 | delta   |
|       5 | b       |     200 | a            |      10 |      99 | alpha   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | d            |   10000 |   99999 | delta   |
|       6 | c       |    1000 | a            |      10 |      99 | alpha   |
|       6 | c       |    1000 | b            |     100 |     999 | bravo   |
|       6 | c       |    1000 | d            |   10000 |   99999 | delta   |
|       7 | c       |    2000 | a            |      10 |      99 | alpha   |
|       7 | c       |    2000 | b            |     100 |     999 | bravo   |
|       7 | c       |    2000 | d            |   10000 |   99999 | delta   |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}
where notice that \verb|CROSS JOIN| can be replaced by a comma ``,''.

It is clear in this table, that the two columns \verb|value_1| from table \verb|test| and \verb|test_join_id| from table \verb|test_join| is probably the logic connection point. In this context, the rows with inconsistent \verb|test.value_1| and \verb|test_join.test_join_id| is meaningless and shall be removed. This can be achieved by the following code.
\begin{lstlisting}
> SELECT * FROM test CROSS JOIN test_join
    -> where test.value_1 = test_join.test_join_id;
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}
and this is equivalent to inner join (or simply, join)
\begin{lstlisting}
> SELECT * FROM test JOIN test_join
    -> ON (test.value_1 = test_join.test_join_id);
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}
where \verb|ON (<table1.column-name> = <table2.column_name>)| is used to indicate the association. The number of columns remain unchanged, but the number of rows depends on the repentance of the associated row with connection in each table. For example, for ``a'', \verb|test.value_1=a| has 3 relevant rows while \verb|test_join.test_join_id=a| has 1 relevant row. Thus, the total number of regarding ``a'' is $3=3\times 1$. The same applies to ``b''.

From table \verb|test| perspective, its rows regarding \verb|value_1| equals to ``a'' and ``b'' are fully included in the inner join results. However, the two rows regarding \verb|value_1=c| is omitted. This is because there is no associated row in the other table \verb|test_join|. It is possible to protect information loss from table \verb|test| by adding these two rows back, with all the columns from table \verb|test_join| filled with NULL. Use left join to achieve this goal as follows.
\begin{lstlisting}
> SELECT * FROM test LEFT JOIN test_join
    -> ON (test.value_1 = test_join.test_join_id);
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
|       6 | c       |    1000 | NULL         |    NULL |    NULL | NULL    |
|       7 | c       |    2000 | NULL         |    NULL |    NULL | NULL    |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}
Alternatively, think of this as temporarily adding one row to \verb|test_join| with \verb|test_join_id=c| and everything else NULL, before the joining.

The same idea applies to right join as well, as shown below.
\begin{lstlisting}
> SELECT * FROM test RIGHT JOIN test_join ON (test.value_1 = test_join.test_join_id);
+---------+---------+---------+--------------+---------+---------+---------+
| test_id | value_1 | value_2 | test_join_id | value_1 | value_2 | value_3 |
+---------+---------+---------+--------------+---------+---------+---------+
|       1 | a       |      10 | a            |      10 |      99 | alpha   |
|       2 | a       |      20 | a            |      10 |      99 | alpha   |
|       3 | a       |      30 | a            |      10 |      99 | alpha   |
|       4 | b       |     100 | b            |     100 |     999 | bravo   |
|       5 | b       |     200 | b            |     100 |     999 | bravo   |
|    NULL | NULL    |    NULL | d            |   10000 |   99999 | delta   |
+---------+---------+---------+--------------+---------+---------+---------+
\end{lstlisting}

Some DBMS supports ``outer join'', which is basically a union of the left and right join results. More about union is introduced later.

The statement \verb|<filter-condition>| applies filtering to the results. Commonly seen filter criteria \verb|<filter-condition>| are summarized as follows.
\begin{itemize}
  \item \verb|<column-name> = <value>|, where \verb|=| can be replaced by \verb|<|, \verb|<=|, \verb|>|, \verb|>=| and \verb|<>|.
  \item \verb|<column-name> IN (<value>, <value>, ...)|
  \item \verb|<column-name> BETWEEN <value> AND <value>|
  \item \verb|<column-name> LIKE <wildcards>|, which compares the column value (usually a string) with a given pattern.
  \item A combination of the above, with \verb|AND| and \verb|OR| joining everything together.
\end{itemize}

A bit more about wildcard query is introduced as follows. A wildcard character is a ``placeholder'' that represents a group of character(s). Most commonly used wildcard characters in the SQL context include
\begin{itemize}
  \item \verb|_|: any single character.
  \item \verb|%|: any string of characters (including empty string).
  \item \verb|[<c1><c2> ...]|: any single character given in the bracket.
  \item \verb|^[<c1><c2>...]|: any single character not given in the bracket.
  \item \verb|[<c1>-<c2>]|: any single character given within the range in the bracket.
\end{itemize}
Wildcard query can be applied to both CHAR and DATE/TIME types, as they can all be characterized as strings.

The \verb|GROUP BY| groups the rows with the same value of the specified column into ``summary rows''. In each summary row, aggregated information is collected. To further explain this, consider the following example. The table used in this example is given below. Consider the same table \verb|test| as follows.
\begin{lstlisting}
> SELECT * FROM test;
+---------+---------+---------+
| test_id | value_1 | value_2 |
+---------+---------+---------+
|       1 | a       |      10 |
|       2 | a       |      20 |
|       3 | a       |      30 |
|       4 | b       |     100 |
|       5 | b       |     200 |
|       6 | c       |    1000 |
|       7 | c       |    2000 |
+---------+---------+---------+
\end{lstlisting}

Consider running the following command.
\begin{lstlisting}
> SELECT * FROM test GROUP BY value_1;
+---------+---------+---------+
| test_id | value_1 | value_2 |
+---------+---------+---------+
|       1 | a       |      10 |
|       4 | b       |     100 |
|       6 | c       |    1000 |
+---------+---------+---------+
\end{lstlisting}
From the result, it can be seen that summary rows have been created using \verb|GROUP BY|. Distinct values from \verb|value_1| have been selected to form each summary row. From the display, only the first appearance of each associated summary row is returned, and a lot of information seems missing. However, it is worth mentioning that although not displayed, the aggregated information is included.

To verify the presence of the aggregated information, consider running the following command.
\begin{lstlisting}
> SELECT COUNT(*) FROM test GROUP BY value_1;
+----------+
| COUNT(*) |
+----------+
|        3 |
|        2 |
|        2 |
+----------+
\end{lstlisting}
From the result, we can see that the counted number of each summary row is returned.

Similarly, the following SQL returns other aggregation information associated with each summary row.
\begin{lstlisting}
> SELECT value_1, COUNT(*), SUM(value_2) FROM test GROUP BY value_1;
+---------+----------+--------------+
| value_1 | COUNT(*) | SUM(value_2) |
+---------+----------+--------------+
| a       |        3 |           60 |
| b       |        2 |          300 |
| c       |        2 |         3000 |
+---------+----------+--------------+
\end{lstlisting}

Finally, \verb|ORDER BY| and \verb|LIMIT| controls the sequence and maximum number of returned rows, respectively.

The returns of multiple queries might be able to \verb|UNION| together, if they are union-compatible. To union the results, use
\begin{lstlisting}
SELECT <...>
UNION
SELECT <...>
UNION
SELECT <...>
...
SELECT <...>;
\end{lstlisting}
where inside \verb|<...>| are the original query statements. Notice that for the queries to be union-compatible, they must have the same number of columns with identical data type for the associated column. The names of the column in the returns, if different, follow the first query result. Use alias \verb|AS| to change the names if needed. Duplicated rows in the union will be excluded. If duplications need to be included in the result, certain DBMS provides the \verb|UNION ALL| option.

SQL uses nest queries to add more flexibility. Nest queries plays as the intermediate steps to provide a temporary searching result, from which another query can be executed. Wherever a table name appears in the query, it can be replaced by a \verb|SELECT| statement nested in a bracket ``()''. A demonstrative example is given below. Consider the same tables \verb|test| and \verb|test_join| as follows.
\begin{lstlisting}
> SELECT * FROM test;
+---------+---------+---------+
| test_id | value_1 | value_2 |
+---------+---------+---------+
|       1 | a       |      10 |
|       2 | a       |      20 |
|       3 | a       |      30 |
|       4 | b       |     100 |
|       5 | b       |     200 |
|       6 | c       |    1000 |
|       7 | c       |    2000 |
+---------+---------+---------+

> SELECT * FROM test_join;
+--------------+---------+---------+---------+
| test_join_id | value_1 | value_2 | value_3 |
+--------------+---------+---------+---------+
| a            |      10 |      99 | alpha   |
| b            |     100 |     999 | bravo   |
| d            |   10000 |   99999 | delta   |
+--------------+---------+---------+---------+
\end{lstlisting}
A inner join is provided to the above tables. However, for each \verb|value_1| in the first table, the sum of the associated \verb|value_2|, instead of each individual row, is used. This can be achieved using
\begin{lstlisting}
> SELECT temp.value_1 AS type,
    ->          temp.sum_value_2 AS total_value,
    ->          test_join.value_1 AS minval,
    ->          test_join.value_2 AS maxval,
    ->          test_join.value_3 AS abbrev
    -> FROM (SELECT value_1,
    ->              SUM(value_2) AS sum_value_2
    ->       FROM test GROUP BY value_1) AS temp
    -> JOIN test_join
    -> ON (temp.value_1 = test_join.test_join_id);
+------+-------------+--------+--------+--------+
| type | total_value | minval | maxval | abbrev |
+------+-------------+--------+--------+--------+
| a    |          60 |     10 |     99 | alpha  |
| b    |         300 |    100 |    999 | bravo  |
+------+-------------+--------+--------+--------+
\end{lstlisting}
where notice that alias are quite some times to clarify the logics.

Nest queries can be popular in table joins as well as filter criteria, where the boundary of a variable can be obtained from a nest query.

\vspace{0.1in}
\noindent \textbf{Trigger}
\vspace{0.1in}

A trigger defines a set of operations to be carried out automatically when something happens to specified tables. For example, in any case a new row is added to a table, a trigger can automatically insert an associated record into a second table.

There are mainly 3 types of triggers: DML trigger (triggered by \verb|INSERT|, \verb|UPDATE|, \verb|DELETE|, etc.), DDL trigger (triggered by \verb|CREATE|, \verb|ALTER|, \verb|DROP|, \verb|GRANT|, \verb|DENY|, \verb|REVOKE|, etc.), and CLR trigger (triggered by LOGON event).

A quick DML trigger can be defined as follows.
\begin{lstlisting}
CREATE TRIGGER <trigger-name>
    [BEFORE | AFTER] [INSERT | UPDATE | DELETE] ON <table-name>
    FOR EACH ROW <operation>;
\end{lstlisting}
where \verb|BRFORE| is often used to validate and modify data to be added to \verb|<table-name>|, and \verb|AFTER| is often used to trigger other changes consequent to this change.

In case multiple operations need to be defined, consider using
\begin{lstlisting}
DELIMITER $$
CREATE TRIGGER <trigger-name>
    [BEFORE | AFTER] [INSERT | UPDATE | DELETE] ON <table-name>
    FOR EACH ROW BEGIN
        <operation>;
        ...
        <operation>;
    END$$
DELIMITER ;
\end{lstlisting}
where \verb|DELIMITER $$| and \verb|DELIMITER ;| is used to temporarily change the delimiter for the \verb|BEGIN...END| statement. It is possible to build slightly complicated logics in the operations, for example to build conditional statements.

Use \verb|NEW| in the operation(s) to represent the rows that is added/updated/deleted from the \verb|table-name|.

Use the following to drop a trigger.
\begin{lstlisting}
DROP TRIGGER <trigger-name>;
\end{lstlisting}

\subsection{MariaDB}

MariaDB and MySQL are two widely used relational DBMS. MariaDB is initially a fork of MySQL, and in this since they share many similarities. While MySQL moves towards a dual license approach (free community license and paid enterprise license with proprietary code), MariaDB is designed to be fully open-source and plays as a replacement of MySQL.

In general, MariaDB supports a larger varieties of data engines and new features, and it is claimed to be faster, more powerful and advanced. However, it lacks some of the enterprise features provided by MySQL. The users can gain these features by using open-source plugins.

In this section, MariaDB is used for demonstration. Notice that both of them shall serve fine for this purpose. Most of the operations introduced in this section, if not all, shall work indifferently on both DBMS.

\vspace{0.1in}
\noindent \textbf{MariaDB Installation}
\vspace{0.1in}

Install MariaDB on a Linux system as follows.
\begin{lstlisting}
$ sudo apt update
$ sudo apt install mariadb-server
\end{lstlisting}
Notice that MySQL can be installed instead by replacing \verb|mariadb-server| with \verb|mysql-server|. Similarly, replace \verb|mariadb| with \verb|mysql| in the rest of this section, wherever applicable. Both DBMS shall work similarly within the scope of this introduction section.

MariaDB server can be controlled using \verb|systemctl|, which is introduced in Section \ref{ch:sa:sec:sc}. For example, to start MariaDB, use
\begin{lstlisting}
$ sudo systemctl start mariadb.service
\end{lstlisting}
and to check its status, use
\begin{lstlisting}
$ sudo systemctl status mariadb
\end{lstlisting}

After installation of and starting MariaDB, use
\begin{lstlisting}
$ sudo mysql_secure_installation
\end{lstlisting}
to run a quick security-related configuration such as creating password for the root user, and deleting test database.

Login to MariaDB console using
\begin{lstlisting}
$ sudo mariadb
\end{lstlisting}
Notice that when \textit{sudo} privilege is used, this should brings the user to the root account of the DBMS. Otherwise, the DBMS may ask the user to provide further login credentials, or deny the login attempt. To login as a particular user, use the following command
\begin{lstlisting}
$ mariadb -u <user-name> -p
Enter Password:
\end{lstlisting}

Notice that in some machines, remote login to the database using the root account is forbidden.

After login to MariaDB console, a prompt that looks like the following would show up.
\begin{lstlisting}
MariaDB [(none)]>
\end{lstlisting}
from where an admin account can be created as follows.
\begin{lstlisting}
MariaDB [(none)]> GRANT ALL PRIVILEGES ON *.* TO '<user-name>'@'localhost' IDENTIFIED BY '<user-password>' WITH GRANT OPTION;
MariaDB [(none)]> FLUSH PRIVILEGES;
\end{lstlisting}
By creating an admin account, the use of root account can be reduced, thus reducing the operation risks. Notice that when using remote connection from another machine to the database, this command is also required to grant access to the remote user with specified IP address. Wildcard expression can be used for the IP address, if necessary.

To check existing users and their IP addresses to whom access has been granted, use
\begin{lstlisting}
SELECT host, user FROM mysql.user;
\end{lstlisting}

Finally, use
\begin{lstlisting}
MariaDB [(none)]> exit
\end{lstlisting}
to quite MariaDB console.

\vspace{0.1in}
\noindent \textbf{A Database Example: Create Database Schema}
\vspace{0.1in}

In the rest of this section, a database is created from scratch as a demonstration of using SQL to interact with MariaDB. The database is used in the smart home project to trace the resources obtained and consumed by the user. The resources in this context may refer to groceries bought from the supermarket, books purchased online, subscriptions of magazines and services, etc.

For simplicity, the prompt is ignored in the rest of this section.

Check the existing databases using
\begin{lstlisting}
SHOW DATABASES;
\end{lstlisting}

A database named \verb|smart_home| is created as follows.
\begin{lstlisting}
CREATE DATABASE smart_home;
\end{lstlisting}

Select the database as follows.
\begin{lstlisting}
USE smart_home;
\end{lstlisting}
With the above command, \verb|smart_home| is selected as the current database.

Based on the database schema design, a few tables need to be created. We shall start with creating \verb|asset|, \verb|accessory|, \verb|consumable| and \verb|subscription| tables as follows.

The \verb|asset| table is used to trace assets in the home. They are often expensive and comes with a serial number or a warranty number, and shall persist for a long time (a few years, at minimum). Examples of assets include beds, televisions, computers, printers, game consoles. The \verb|accessory| table is used to trace relatively cheaper accessories than assets. Though they are designed to last long, they may not have an serial number. Examples of accessories include books, charging cables, coffee cups. The \verb|consumable| table is used to trace items that is meant to be used up or expire. Examples of consumable items include food, shampoo, A4 printing paper. And finally the \verb|subscription| table is used to trace subscriptions of services. Examples of these services include software license (either permanent license or annual subscription license), magazine subscriptions, membership subscriptions, and digital procurement of a movie.

The serial number or warranty number for assets are used as the primary key of \verb|asset| table. For the other three tables, surrogate keys are used. Each table has a column \verb|product_type_id| that specifies the type of the item, such as ``television'', ``cooker'', ``fruit'', ``software''. The types in these tables are given by integer indices. A separate \verb|product_type| relates the indices with their associated meanings. The same applies to \verb|product_brand_id| and \verb|payment_method_id|.

Create \verb|asset| table as follows.
\begin{lstlisting}
CREATE TABLE asset (
    PRIMARY KEY (serial_num),
    serial_num                  VARCHAR(50)     NOT NULL,
    product_type_id             INT(5),
    product_brand_id            INT(5),
    product_name                VARCHAR(50)     NOT NULL,
    receipt_num                 VARCHAR(50),
    procured_date               DATE            NOT NULL DEFAULT (CURRENT_DATE),
    procured_price              DECIMAL(10,2),
    payment_method_id           INT(5),
    warranty_date_1             DATE            NOT NULL DEFAULT (CURRENT_DATE),
    warranty_date_2             DATE            NOT NULL DEFAULT (CURRENT_DATE),
    expire_date                 DATE            NOT NULL DEFAULT '9999-12-31',
                                CONSTRAINT warranty_after_procured
                                CHECK(warranty_date_1 >= procured_date AND warranty_date_2 >= warranty_date_1),
                                CONSTRAINT expire_after_procured
                                CHECK(expire_date >= procured_date)
);
\end{lstlisting}
where
\begin{itemize}
  \item \verb|serial_num|: the serial number, MAC number or registration ID that can be used to uniquely identify the asset.
  \item \verb|product_type_id|: type index.
  \item \verb|product_brand_id|: brand index.
  \item \verb|product_name|: full name of the product that can uniquely specify the asset on the market.
  \item \verb|receipt_num|: receipt and/or warranty number.
  \item \verb|procured_date|: date of procurement.
  \item \verb|procured_price|: price of the product as procured.
  \item \verb|payment_method_id|: payment method.
  \item \verb|warranty_date_1|: warranty expiration date (free replace or repair); leave it as the procured date if no such warranty is issued.
  \item \verb|warranty_date_2|: second warranty expiration date (partially covered repair); leave it as the procured date if no such warranty is issued.
  \item \verb|expire_date|: the date when the asset expires or needs to be returned. For example, in Singapore a car ``expires'' in 10 years from the day of procurement.
\end{itemize}
Notice that constraints and default values have been added to the table creation. An SQL script is used contain the code, and
\begin{lstlisting}
$ mariadb -u <user-name> -p < <script-name>
\end{lstlisting}
is used to execute the script, which is more convinient than typing all the lines in the MariaDB console.

Similarly, create the rest 3 tables for the resources as follows.
\begin{lstlisting}
CREATE TABLE accessory (
    PRIMARY KEY (item_id),
    item_id                     INT(5)          AUTO_INCREMENT,
    product_type_id             INT(5),
    product_brand_id            INT(5),
    product_name                VARCHAR(50)     NOT NULL,
    receipt_num                 VARCHAR(50),
    procured_date               DATE            NOT NULL DEFAULT (CURRENT_DATE),
    procured_number             DECIMAL(10,2)   NOT NULL DEFAULT 1.00,
    procured_unit_price         DECIMAL(10,2),
    procured_price              DECIMAL(10,2),
    payment_method_id           INT(5),
    expire_date                 DATE            NOT NULL DEFAULT '9999-12-31',
                                CONSTRAINT expire_after_procured
                                CHECK(expire_date >= procured_date)
);

CREATE TABLE consumable (
    PRIMARY KEY (item_id),
    item_id                     INT(5)          AUTO_INCREMENT,
    product_type_id             INT(5),
    product_brand_id            INT(5),
    product_name                VARCHAR(50)     NOT NULL,
    receipt_num                 VARCHAR(50),
    procured_date               DATE            NOT NULL DEFAULT (CURRENT_DATE),
    procured_number             DECIMAL(10,2)   NOT NULL DEFAULT 1.00,
    procured_unit_price         DECIMAL(10,2),
    procured_price              DECIMAL(10,2),
    payment_method_id           INT(5),
    expire_date                 DATE            NOT NULL DEFAULT (CURRENT_DATE),
                                CONSTRAINT expire_after_procured
                                CHECK(expire_date >= procured_date)
);

CREATE TABLE subscription (
    PRIMARY KEY (item_id),
    item_id                     INT(5)          AUTO_INCREMENT,
    product_type_id             INT(5),
    product_brand_id            INT(5),
    product_name                VARCHAR(50)     NOT NULL,
    receipt_num                 VARCHAR(50),
    procured_date               DATE            NOT NULL DEFAULT (CURRENT_DATE),
    procured_price              DECIMAL(10,2),
    payment_method_id           INT(5),
    expire_date                 DATE            NOT NULL DEFAULT (CURRENT_DATE),
                                CONSTRAINT expire_after_procured
                                CHECK(expire_date >= procured_date)
);
\end{lstlisting}

Create the tables for users, product types, product brands and payment methods as follows.
\begin{lstlisting}
CREATE TABLE user (
    PRIMARY KEY (user_id),
    user_id                     INT(5),
    first_name                  VARCHAR(50)     NOT NULL,
    last_name                   VARCHAR(50)     NOT NULL,
    email                       VARCHAR(50)     NOT NULL UNIQUE
);

CREATE TABLE product_type (
    PRIMARY KEY (product_type_id),
    product_type_id             INT(5)          AUTO_INCREMENT,
    product_type_name           VARCHAR(50)     NOT NULL UNIQUE,
    product_type_name_sub       VARCHAR(50)     NOT NULL DEFAULT ('na')
);

CREATE TABLE product_brand (
    PRIMARY KEY (product_brand_id),
    product_brand_id            INT(5)          AUTO_INCREMENT,
    product_brand_name          VARCHAR(50)     NOT NULL UNIQUE
);

CREATE TABLE payment_method (
    PRIMARY KEY (payment_method_id),
    payment_method_id           INT(50)         AUTO_INCREMENT,
    user_id                     INT(5),
    payment_method_name         VARCHAR(50)     NOT NULL
);
\end{lstlisting}

Finally, create foreign keys as follows.
\begin{lstlisting}
ALTER TABLE payment_method
ADD FOREIGN KEY (user_id)
REFERENCES user(user_id);
ALTER TABLE asset
ADD FOREIGN KEY (product_type_id)
REFERENCES product_type(product_type_id);
ALTER TABLE asset
ADD FOREIGN KEY (product_brand_id)
REFERENCES product_brand(product_brand_id);
ALTER TABLE asset
ADD FOREIGN KEY (payment_method_id)
REFERENCES payment_method(payment_method_id);
ALTER TABLE accessory
ADD FOREIGN KEY (product_type_id)
REFERENCES product_type(product_type_id);
ALTER TABLE accessory
ADD FOREIGN KEY (product_brand_id)
REFERENCES product_brand(product_brand_id);
ALTER TABLE accessory
ADD FOREIGN KEY (payment_method_id)
REFERENCES payment_method(payment_method_id);
ALTER TABLE consumable
ADD FOREIGN KEY (product_type_id)
REFERENCES product_type(product_type_id);
ALTER TABLE consumable
ADD FOREIGN KEY (product_brand_id)
REFERENCES product_brand(product_brand_id);
ALTER TABLE consumable
ADD FOREIGN KEY (payment_method_id)
REFERENCES payment_method(payment_method_id);
ALTER TABLE subscription
ADD FOREIGN KEY (product_type_id)
REFERENCES product_type(product_type_id);
ALTER TABLE subscription
ADD FOREIGN KEY (product_brand_id)
REFERENCES product_brand(product_brand_id);
ALTER TABLE subscription
ADD FOREIGN KEY (payment_method_id)
REFERENCES payment_method(payment_method_id);
\end{lstlisting}

\vspace{0.1in}
\noindent \textbf{A Database Example: Insert Data}
\vspace{0.1in}

xxx


\subsection{RDS Access Using Python}

Python provides variety of libraries to access RDS, many of which use embedded SQL codes to interact with the DBMS. Depending on the DBMS, different libraries and commands can be used, some of which more general and the other more specific to a particular DBMS.

In this section, both \verb|pandas| and \verb|mariadb| libraries are introduced. The \verb|pandas| library provides data manipulation and analysis tools, and it provides \verb|pandas.io.sql| that allows connecting to a DBMS and embedding SQL commands into the python code. The \verb|mariadb| library, on the other hand, is dedicated for MariaDB connection. Like \verb|pandas.io.sql|, it also allows embedding SQL commands to interface the DMBS.

As pre-requisitions, make sure that the following has been done.
\begin{itemize}
  \item The DBMS has been configured to allow remote access.
  \item Make sure that an account has been registered in DBMS that has the privilege of operation from a remote machine.
  \item Make sure that the firewall configuration is correct.
\end{itemize}

For DBMS configuration, in the case of MariaDB, use the following code in the shell to check the location of the configuration files.
\begin{lstlisting}
$ mysqld --help --verbose
\end{lstlisting}
Typical locations of the configuration files are \verb|/etc/my.cnf| and \verb|/etc/mysql/my.cnf|. In the configuration file, use the following to disable binding address.
\begin{lstlisting}
[mysqld]
skip-networking=0
skip-bind-address
\end{lstlisting}

For account setup, in the DBMS console, use something like
\begin{lstlisting}
> GRANT ALL PRIVILEGES ON *.* TO '<user-name>'@'<ip-address>' IDENTIFIED BY '<user-password>' WITH GRANT OPTION;
\end{lstlisting}
where \verb|'<ip-address>'| is the remote machine that runs the Python program. If the Python codes are running locally, simply use \verb|'localhost'|.

It might be necessary to install MariaDB database development files in the DMBS host machine for the Python libraries to be introduced to function properly. Install the development as follows.
\begin{lstlisting}
$ sudo apt install libmariadb-dev
\end{lstlisting}

\vspace{0.1in}
\noindent \textbf{PANDAS Library}
\vspace{0.1in}

Python library \verb|pandas| is one of the essential libraries for data analysis. It provides flexible interfaces and tools for data reading and processing and works very well with different data formats and engines including CSV, EXCEL and DBMS. This section focuses mainly on the interaction of \verb|pandas| with DBMS. Therefore, the detailed use of \verb|pandas| for data analysis, etc., are not covered in this section.

A class \verb|pandas.DataFrame| is defined in \verb|pandas| as the backbone to store and process data. The data attribute of \verb|pandas.DataFrame| is a \verb|numpy| array. Many functions are provided to read different data formats into \verb|pandas| data frame, which makes reading data easy and convenient. An example of reading a CSV file is given below.
\begin{lstlisting}
import pandas as pd
df = pd.read_csv(<file-name>)
print(df)
print(df.head(<number>))
print(df.tail(<number>))
print(df.info())
\end{lstlisting}
where \verb|head()|, \verb|tail()| gives the first and last rows of the data frame, and \verb|info()| checks the data frame basic information including shape and data types of the columns. Check \verb|df.columns| for all the columns of the data frame. Details specific to a column can be accessed via \verb|df.[<column-name>]|. Many functions are provided to further abstract the details, such as grouping and counting. Use \verb|df.loc(<row-index-list>, <column-name-list>)| to check the content of specified rows and columns.

With \verb|pandas| and other relavent libraries, Python can connect to a database and execute a query. An example of using \verb|pandas| to connect to an Microsoft SQL server and implement a query is given below. Notice that different DBMS may require different database connectivity driver standards, and there are mainly two of them, namely open database connectivity (ODBC) and Java database connectivity (JDBC). Microsoft adopts ODBC, and a separate package is required in the Python program to connect to the Microsoft SQL server.
\begin{lstlisting}
import pyodbc
import pandas.io.sql as psql

server = "<server-url>,<port>"
database = "<database>"
uid = "<uid>"
pwd = "<pwd>"
driver = "<driver>" # such as "{ODBC Driver 17 for SQL Server}"

# connect to database
conn = pyodbc.connect(
	server = server,
	database = database,
	uid = uid,
	pwd = pwd,
	driver = driver
)

# get cursor
cursor = conn.cursor()

# execute sql command
query = """<query>"""
runs = psql.read_sql_query(query, conn)
\end{lstlisting}
The above codes returns a data frame corresponding to the result set of the query string, which is saved in \verb|runs|.

\vspace{0.1in}
\noindent \textbf{MARIADB Library}
\vspace{0.1in}

Use the following code to test connectivity from Python to the database.
\begin{lstlisting}
import mariadb
import sys

user = "<user>"
password = "<password>"
host = "<server-url>"
port = "<port>" # MariaDB default: 3306
database = "<database>"

# connect to database
try:
    conn = mariadb.connect(
        user = user,
        password = password,
        host = host,
        port = port,
        database = database
    )
except mariadb.Error as e:
    print(f"Error connecting to MariaDB Platform: {e}")
    sys.exit(1)

# get cursor
cur = conn.cursor()

# execute sql command
cur.execute("<sql-command>")
\end{lstlisting}
Notice that for query, the result is stored in the cursor object. Use a for loop to view the results.

\section{Non-relational Database}

...

\subsection{Brief Introduction to Non-relational Database}
...

\subsection{MangoDB}
...

